async function o(a){let e=await fetch(a,{credentials:"same-origin"}).then(async n=>await n.text());return URL.createObjectURL(new Blob([e],{type:"text/javascript"}))}var s=class{constructor(){return(async()=>{if(import.meta.url.includes("/src/"))this.worker=new Worker(new URL("./libraw-mini-worker.js",import.meta.url),{type:"module"});else{let t=new URL("./libraw-mini-worker.js",import.meta.url),r=await o(t.href);this.worker=new Worker(r,{type:"module"}),URL.revokeObjectURL(r)}return this.waitForWorker=!1,this.worker.onmessage=({data:t})=>{if(t?.out?.cb&&this.cb)return this.cb(t.out.count,t.out.msg);if(this.waitForWorker){let{return:r,error:i}=this.waitForWorker;this.waitForWorker=!1,t?.error?i(t.error):r(t?.out)}},await new Promise((t,r)=>{this.waitForWorker={error:r,return:t}}),this})()}async runFn(e,...n){let t=new Promise((r,i)=>{this.waitForWorker={error:i,return:r}});return this.worker.postMessage({fn:e,args:n},n.map(r=>{if([ArrayBuffer,Uint8Array,Int8Array,Uint16Array,Int16Array,Uint32Array,Int32Array,Float32Array,Float64Array].some(i=>r instanceof i))return r.buffer}).filter(r=>r)),await t}async init(){return await this.runFn("init",null,null)}async open(e,n){return await this.runFn("open",e,n)}async close(){return await this.runFn("close",null,null)}async getimage(e=null){return e&&(this.cb=e),await this.runFn("get_image",null,null)}async getthumbnail(){return await this.runFn("get_thumb",null,null)}async getmetadata(){return await this.runFn("get_metadata",null,null)}async setparams(e){return await this.runFn("set_params",e,null)}async version(){return await this.runFn("version",null,null)}};export{s as LibRaw};
